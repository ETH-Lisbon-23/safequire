{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@safe-global/safe-core-protocol/contracts/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.18;\n\nstruct SafeProtocolAction {\n    address payable to;\n    uint256 value;\n    bytes data;\n}\n\nstruct SafeTransaction {\n    SafeProtocolAction[] actions;\n    uint256 nonce;\n    bytes32 metadataHash;\n}\n\nstruct SafeRootAccess {\n    SafeProtocolAction action;\n    uint256 nonce;\n    bytes32 metadataHash;\n}\n"
    },
    "@safe-global/safe-core-protocol/contracts/interfaces/Accounts.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.18;\n\n/**\n * @title ISafe Declares the functions that are called on a Safe by Safe{Core} Protocol.\n */\ninterface ISafe {\n    function execTransactionFromModule(\n        address payable to,\n        uint256 value,\n        bytes calldata data,\n        uint8 operation\n    ) external returns (bool success);\n\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint8 operation\n    ) external returns (bool success, bytes memory returnData);\n}\n"
    },
    "@safe-global/safe-core-protocol/contracts/interfaces/Integrations.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.18;\nimport {ISafe} from \"./Accounts.sol\";\nimport {SafeTransaction, SafeRootAccess} from \"../DataTypes.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title ISafeProtocolFunctionHandler - An interface that a Safe function handler should implement to handle static calls.\n * @notice In Safe{Core} Protocol, a function handler can be used to add additional functionality to a Safe.\n *         User(s) should add SafeProtocolManager as a function handler (aka fallback handler in Safe v1.x) to the Safe\n *         and enable the contract implementing ISafeProtocolFunctionHandler interface as a function handler in the\n *         SafeProtocolManager for the specific function identifier.\n */\ninterface ISafeProtocolFunctionHandler is IERC165 {\n    /**\n     * @notice Handles calls to the Safe contract forwarded by the fallback function.\n     * @param safe A Safe instance\n     * @param sender Address of the sender\n     * @param value Amount of ETH\n     * @param data Arbitrary length bytes\n     * @return result Arbitrary length bytes containing result of the operation\n     */\n    function handle(ISafe safe, address sender, uint256 value, bytes calldata data) external returns (bytes memory result);\n\n    /**\n     * @notice A function that returns information about the type of metadata provider and its location.\n     *         For more information on metadata provider, refer to https://github.com/safe-global/safe-core-protocol-specs/.\n     * @return providerType uint256 Type of metadata provider\n     * @return location bytes\n     */\n    function metadataProvider() external view returns (uint256 providerType, bytes memory location);\n}\n\n/**\n * @title ISafeProtocolStaticFunctionHandler - An interface that a Safe functionhandler should implement in case when handling static calls\n * @notice In Safe{Core} Protocol, a function handler can be used to add additional functionality to a Safe.\n *         User(s) should add SafeProtocolManager as a function handler (aka fallback handler in Safe v1.x) to the Safe\n *         and enable the contract implementing ISafeProtocolStaticFunctionHandler interface as a function handler in the\n *         SafeProtocolManager for the specific function identifier.\n */\ninterface ISafeProtocolStaticFunctionHandler is IERC165 {\n    /**\n     * @notice Handles static calls to the Safe contract forwarded by the fallback function.\n     * @param safe A Safe instance\n     * @param sender Address of the sender\n     * @param value Amount of ETH\n     * @param data Arbitrary length bytes\n     * @return result Arbitrary length bytes containing result of the operation\n     */\n    function handle(ISafe safe, address sender, uint256 value, bytes calldata data) external view returns (bytes memory result);\n\n    /**\n     * @notice A function that returns information about the type of metadata provider and its location.\n     *         For more information on metadata provider, refer to https://github.com/safe-global/safe-core-protocol-specs/.\n     * @return providerType uint256 Type of metadata provider\n     * @return location bytes\n     */\n    function metadataProvider() external view returns (uint256 providerType, bytes memory location);\n}\n\n/**\n * @title ISafeProtocolHooks - An interface that a contract should implement to be enabled as hooks.\n * @notice In Safe{Core} Protocol, hooks can approve or deny transactions based on the logic it implements.\n */\ninterface ISafeProtocolHooks is IERC165 {\n    /**\n     * @notice A function that will be called by a Safe before the execution of a transaction if the hooks are enabled\n     * @dev Add custom logic in this function to validate the pre-state and contents of transaction for non-root access.\n     * @param safe A Safe instance\n     * @param tx A struct of type SafeTransaction that contains the details of the transaction.\n     * @param executionType uint256\n     * @param executionMeta Arbitrary length of bytes\n     * @return preCheckData bytes\n     */\n    function preCheck(\n        ISafe safe,\n        SafeTransaction calldata tx,\n        uint256 executionType,\n        bytes calldata executionMeta\n    ) external returns (bytes memory preCheckData);\n\n    /**\n     * @notice A function that will be called by a safe before the execution of a transaction if the hooks are enabled and\n     *         transaction requies tool access.\n     * @dev Add custom logic in this function to validate the pre-state and contents of transaction for root access.\n     * @param safe A Safe instance\n     * @param rootAccess DataTypes.SafeRootAccess\n     * @param executionType uint256\n     * @param executionMeta bytes\n     * @return preCheckData bytes\n     */\n    function preCheckRootAccess(\n        ISafe safe,\n        SafeRootAccess calldata rootAccess,\n        uint256 executionType,\n        bytes calldata executionMeta\n    ) external returns (bytes memory preCheckData);\n\n    /**\n     * @notice A function that will be called by a safe after the execution of a transaction if the hooks are enabled. Hooks should revert if the post state of after the transaction is not as expected.\n     * @dev Add custom logic in this function to validate the post-state after the transaction is executed.\n     * @param safe ISafe\n     * @param success bool\n     * @param preCheckData Arbitrary length bytes that was returned by during pre-check of the transaction.\n     */\n    function postCheck(ISafe safe, bool success, bytes calldata preCheckData) external;\n}\n\n/**\n * @title ISafeProtocolPlugin - An interface that a Safe plugin should implement\n */\ninterface ISafeProtocolPlugin is IERC165 {\n    /**\n     * @notice A funtion that returns name of the plugin\n     * @return name string name of the plugin\n     */\n    function name() external view returns (string memory name);\n\n    /**\n     * @notice A function that returns version of the plugin\n     * @return version string version of the plugin\n     */\n    function version() external view returns (string memory version);\n\n    /**\n     * @notice A function that returns information about the type of metadata provider and its location.\n     *         For more information on metadata provider, refer to https://github.com/safe-global/safe-core-protocol-specs/.\n     * @return providerType uint256 Type of metadata provider\n     * @return location bytes\n     */\n    function metadataProvider() external view returns (uint256 providerType, bytes memory location);\n\n    /**\n     * @notice A function that indicates if the plugin requires root access to a Safe.\n     * @return requiresRootAccess True if root access is required, false otherwise.\n     */\n    function requiresRootAccess() external view returns (bool requiresRootAccess);\n}\n"
    },
    "@safe-global/safe-core-protocol/contracts/interfaces/Manager.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.18;\nimport {ISafe} from \"./Accounts.sol\";\nimport {SafeRootAccess, SafeTransaction} from \"../DataTypes.sol\";\n\n/**\n * @title ISafeProtocolManager interface a Manager should implement\n * @notice A mediator checks the status of the integration through the registry and allows only\n *         listed and non-flagged integrations to execute transactions. A Safe account should\n *         add a mediator as a plugin.\n */\ninterface ISafeProtocolManager {\n    /**\n     * @notice This function allows enabled plugins to execute non-delegate call transactions thorugh a Safe.\n     *         It should validate the status of the plugin through the registry and allows only listed and non-flagged integrations to execute transactions.\n     * @param safe Address of a Safe account\n     * @param transaction SafeTransaction instance containing payload information about the transaction\n     * @return data Array of bytes types returned upon the successful execution of all the actions. The size of the array will be the same as the size of the actions\n     *         in case of succcessful execution. Empty if the call failed.\n     */\n    function executeTransaction(ISafe safe, SafeTransaction calldata transaction) external returns (bytes[] memory data);\n\n    /**\n     * @notice This function allows enabled plugins to execute delegate call transactions thorugh a Safe.\n     *         It should validate the status of the plugin through the registry and allows only listed and non-flagged integrations to execute transactions.\n     * @param safe Address of a Safe account\n     * @param rootAccess SafeTransaction instance containing payload information about the transaction\n     * @return data Arbitrary length bytes data returned upon the successful execution. The size of the array will be the same as the size of the actions\n     *         in case of succcessful execution. Empty if the call failed.\n     */\n    function executeRootAccess(ISafe safe, SafeRootAccess calldata rootAccess) external returns (bytes memory data);\n}\n"
    },
    "contracts/Base.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.18;\n\nimport {ISafeProtocolPlugin} from \"@safe-global/safe-core-protocol/contracts/interfaces/Integrations.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nenum MetadataProviderType {\n    IPFS,\n    URL,\n    Contract,\n    Event\n}\n\ninterface IMetadataProvider {\n    function retrieveMetadata(bytes32 metadataHash) external view returns (bytes memory metadata);\n}\n\nstruct PluginMetadata {\n    string name;\n    string version;\n    bool requiresRootAccess;\n    string iconUrl;\n    string appUrl;\n}\n\nlibrary PluginMetadataOps {\n    function encode(PluginMetadata memory data) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                uint8(0x00), // Format\n                uint8(0x00), // Format version\n                abi.encode(data.name, data.version, data.requiresRootAccess, data.iconUrl, data.appUrl) // Plugin Metadata\n            );\n    }\n\n    function decode(bytes calldata data) internal pure returns (PluginMetadata memory) {\n        require(bytes16(data[0:2]) == bytes16(0x0000), \"Unsupported format or format version\");\n        (string memory name, string memory version, bool requiresRootAccess, string memory iconUrl, string memory appUrl) = abi.decode(\n            data[2:],\n            (string, string, bool, string, string)\n        );\n        return PluginMetadata(name, version, requiresRootAccess, iconUrl, appUrl);\n    }\n}\n\nabstract contract BasePlugin is ISafeProtocolPlugin {\n    using PluginMetadataOps for PluginMetadata;\n\n    string public name;\n    string public version;\n    bool public immutable requiresRootAccess;\n    bytes32 public immutable metadataHash;\n\n    constructor(PluginMetadata memory metadata) {\n        name = metadata.name;\n        version = metadata.version;\n        requiresRootAccess = metadata.requiresRootAccess;\n        metadataHash = keccak256(metadata.encode());\n    }\n\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\n        return interfaceId == type(ISafeProtocolPlugin).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n}\n\nabstract contract BasePluginWithStoredMetadata is BasePlugin, IMetadataProvider {\n    using PluginMetadataOps for PluginMetadata;\n\n    bytes private encodedMetadata;\n\n    constructor(PluginMetadata memory metadata) BasePlugin(metadata) {\n        encodedMetadata = metadata.encode();\n    }\n\n    function retrieveMetadata(bytes32 _metadataHash) external view override returns (bytes memory metadata) {\n        require(metadataHash == _metadataHash, \"Cannot retrieve metadata\");\n        return encodedMetadata;\n    }\n\n    function metadataProvider() public view override returns (uint256 providerType, bytes memory location) {\n        providerType = uint256(MetadataProviderType.Contract);\n        location = abi.encode(address(this));\n    }\n}\n\nabstract contract BasePluginWithEventMetadata is BasePlugin {\n    using PluginMetadataOps for PluginMetadata;\n\n    event Metadata(bytes32 indexed metadataHash, bytes data);\n\n    constructor(PluginMetadata memory metadata) BasePlugin(metadata) {\n        emit Metadata(metadataHash, metadata.encode());\n    }\n\n    function metadataProvider() public view override returns (uint256 providerType, bytes memory location) {\n        providerType = uint256(MetadataProviderType.Event);\n        location = abi.encode(address(this));\n    }\n}\n"
    },
    "contracts/SafequirePlugin.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.18;\nimport {ISafe} from \"@safe-global/safe-core-protocol/contracts/interfaces/Accounts.sol\";\nimport {ISafeProtocolManager} from \"@safe-global/safe-core-protocol/contracts/interfaces/Manager.sol\";\nimport {SafeTransaction, SafeProtocolAction} from \"@safe-global/safe-core-protocol/contracts/DataTypes.sol\";\nimport {BasePluginWithEventMetadata, PluginMetadata} from \"./Base.sol\";\n\n/**\n * @title OwnerManager\n * @dev This interface is defined for use in SafequirePlugin contract.\n */\ninterface OwnerManager {\n    function isOwner(address owner) external view returns (bool);\n}\n\n/**\n * @title SafequirePlugin maintains a mapping that stores information about accounts that are\n *        permitted to execute non-root transactions through a Safe account.\n * @notice This plugin does not need Safe owner(s) confirmation(s) to execute Safe txs once enabled\n *         through a Safe{Core} Protocol Manager.\n */\ncontract SafequirePlugin is BasePluginWithEventMetadata {\n    // safe account => account => Safequire status\n    mapping(address => mapping(address => bool)) public whitelistedAddresses;\n\n    event AddressWhitelisted(address indexed account);\n    event AddressRemovedFromWhitelist(address indexed account);\n\n    error AddressNotWhiteListed(address account);\n    error CallerIsNotOwner(address safe, address caller);\n\n    constructor()\n        BasePluginWithEventMetadata(\n            PluginMetadata({name: \"Safequire Plugin\", version: \"1.0.0\", requiresRootAccess: false, iconUrl: \"\", appUrl: \"https://google.com\"})\n        )\n    {}\n\n    /**\n     * @notice Executes a Safe transaction if the caller is whitelisted for the given Safe account.\n     * @param manager Address of the Safe{Core} Protocol Manager.\n     * @param safe Safe account\n     * @param safetx SafeTransaction to be executed\n     */\n    function executeFromPlugin(\n        ISafeProtocolManager manager,\n        ISafe safe,\n        SafeTransaction calldata safetx\n    ) external returns (bytes[] memory data) {\n        address safeAddress = address(safe);\n        // Only Safe owners are allowed to execute transactions to whitelisted accounts.\n        if (!(OwnerManager(safeAddress).isOwner(msg.sender))) {\n            revert CallerIsNotOwner(safeAddress, msg.sender);\n        }\n\n        SafeProtocolAction[] memory actions = safetx.actions;\n        uint256 length = actions.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (!whitelistedAddresses[safeAddress][actions[i].to]) revert AddressNotWhiteListed(actions[i].to);\n        }\n        // Test: Any tx that updates whitelist of this contract should be blocked\n        (data) = manager.executeTransaction(safe, safetx);\n    }\n\n    /**\n     * @notice Adds an account to whitelist mapping.\n     *         The caller should be a Safe account.\n     * @param account address of the account to be whitelisted\n     */\n    function addToWhitelist(address account) external {\n        whitelistedAddresses[msg.sender][account] = true;\n        emit AddressWhitelisted(account);\n    }\n\n    /**\n     * @notice Removes an account from whitelist mapping.\n     *         The caller should be a Safe account.\n     * @param account address of the account to be removed from the whitelist\n     */\n    function removeFromWhitelist(address account) external {\n        whitelistedAddresses[msg.sender][account] = false;\n        emit AddressRemovedFromWhitelist(account);\n    }\n}\n"
    },
    "contracts/WhitelistPlugin.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.18;\nimport {ISafe} from \"@safe-global/safe-core-protocol/contracts/interfaces/Accounts.sol\";\nimport {ISafeProtocolManager} from \"@safe-global/safe-core-protocol/contracts/interfaces/Manager.sol\";\nimport {SafeTransaction, SafeProtocolAction} from \"@safe-global/safe-core-protocol/contracts/DataTypes.sol\";\nimport {BasePluginWithEventMetadata, PluginMetadata} from \"./Base.sol\";\n\n/**\n * @title OwnerManager\n * @dev This interface is defined for use in WhitelistPlugin contract.\n */\ninterface OwnerManager {\n    function isOwner(address owner) external view returns (bool);\n}\n\n/**\n * @title WhitelistPlugin maintains a mapping that stores information about accounts that are\n *        permitted to execute non-root transactions through a Safe account.\n * @notice This plugin does not need Safe owner(s) confirmation(s) to execute Safe txs once enabled\n *         through a Safe{Core} Protocol Manager.\n */\ncontract WhitelistPlugin is BasePluginWithEventMetadata {\n    // safe account => account => whitelist status\n    mapping(address => mapping(address => bool)) public whitelistedAddresses;\n\n    event AddressWhitelisted(address indexed account);\n    event AddressRemovedFromWhitelist(address indexed account);\n\n    error AddressNotWhiteListed(address account);\n    error CallerIsNotOwner(address safe, address caller);\n\n    constructor()\n        BasePluginWithEventMetadata(\n            PluginMetadata({name: \"Whitelist Plugin\", version: \"1.0.0\", requiresRootAccess: false, iconUrl: \"\", appUrl: \"\"})\n        )\n    {}\n\n    /**\n     * @notice Executes a Safe transaction if the caller is whitelisted for the given Safe account.\n     * @param manager Address of the Safe{Core} Protocol Manager.\n     * @param safe Safe account\n     * @param safetx SafeTransaction to be executed\n     */\n    function executeFromPlugin(\n        ISafeProtocolManager manager,\n        ISafe safe,\n        SafeTransaction calldata safetx\n    ) external returns (bytes[] memory data) {\n        address safeAddress = address(safe);\n        // Only Safe owners are allowed to execute transactions to whitelisted accounts.\n        if (!(OwnerManager(safeAddress).isOwner(msg.sender))) {\n            revert CallerIsNotOwner(safeAddress, msg.sender);\n        }\n\n        SafeProtocolAction[] memory actions = safetx.actions;\n        uint256 length = actions.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (!whitelistedAddresses[safeAddress][actions[i].to]) revert AddressNotWhiteListed(actions[i].to);\n        }\n        // Test: Any tx that updates whitelist of this contract should be blocked\n        (data) = manager.executeTransaction(safe, safetx);\n    }\n\n    /**\n     * @notice Adds an account to whitelist mapping.\n     *         The caller should be a Safe account.\n     * @param account address of the account to be whitelisted\n     */\n    function addToWhitelist(address account) external {\n        whitelistedAddresses[msg.sender][account] = true;\n        emit AddressWhitelisted(account);\n    }\n\n    /**\n     * @notice Removes an account from whitelist mapping.\n     *         The caller should be a Safe account.\n     * @param account address of the account to be removed from the whitelist\n     */\n    function removeFromWhitelist(address account) external {\n        whitelistedAddresses[msg.sender][account] = false;\n        emit AddressRemovedFromWhitelist(account);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}